# Gameplan: No Charge Prices for Usage Meters

**Project Name:** `no-charge-prices`

---

## Problem Statement

Currently, usage events can be created without a price by specifying a `usageMeterId` or `usageMeterSlug`. This results in "priceless" usage events that are difficult to handle in billing and reporting. We need a reliable fallback pricing mechanism where every usage meter has a guaranteed default price, while still allowing merchants to configure custom default prices.

---

## Solution Summary

Introduce an auto-generated "no charge" price for every usage meter with the reserved slug pattern `{usagemeterslug}_no_charge`. This price acts as the ultimate fallback when no other price is set as default. When merchants create usage events using a usage meter identifier (instead of a price identifier), the system will automatically use the meter's default price. Merchants can set any price as the default, but if they unset the current default, the no_charge price becomes the default. The no_charge slug pattern is reserved and cannot be used for user-created prices.

---

## Behavioral Summary

After this gameplan lands:

1. **Users can set any price (including non-$0 prices) as the default** for a usage meter
2. **Usage events created with a meter identifier use the default price** - when a merchant uses `usageMeterId` or `usageMeterSlug` instead of `priceId`, the system resolves to the meter's default price (currently this creates events with `priceId: null`)
3. **Every usage meter has a `{usagemeterslug}_no_charge` price** - this $0 fallback is the guaranteed default when no other price is set as default
4. **No charge prices are auto-created** for all new usage meters and backfilled to existing ones
5. **The `_no_charge` slug suffix is reserved** for usage prices only and cannot be used for user-created prices
6. **In pricing.yaml, users cannot specify no_charge prices** - these are auto-generated by the system

---

## Current State Analysis

### Usage Event Creation (without explicit price)

**File:** `src/utils/usage/usageEventHelpers.ts` (~line 254)

When `usageMeterSlug` is provided, `resolveUsageEventInput()` returns `{priceId: null, usageMeterId}`. This allows priceless usage events.

**File:** `src/utils/usage/bulkInsertUsageEventsTransaction.ts` (~line 284)

Bulk insert explicitly sets `priceId: null` when using meter slug identifiers.

### Pricing Model Setup

**File:** `src/utils/pricingModels/setupTransaction.ts` (~line 83)

Usage meters are created during `setupPricingModelTransaction()`, but no automatic prices are created for them.

### Default Price Semantics

**File:** `src/db/schema/prices.ts` (~line 139)

The `isDefault` unique index enforces one default price per product (for non-usage prices). Per the existing gameplan (GAMEPLAN_DATA_MODEL_PRICES-2-1.md), this will be split to also enforce one default per usage meter for usage prices.

### Slug Validation

**File:** `src/utils/pricingModels/setupSchemas.ts` (~line 129)

`slugsAreUnique()` validates unique slugs but does not currently reserve any slug patterns.

---

## Required Changes

### Patch 1: Reserved Slug Validation (Usage Prices Only)

**File:** `src/utils/pricingModels/setupSchemas.ts`

Add validation to reject user-specified **usage prices** with the `_no_charge` suffix:

```ts
export const isReservedPriceSlug = (slug: string): boolean => {
  return slug.endsWith('_no_charge')
}

// Add to price validation in setupPricingModelUsagePriceSchema ONLY:
// This validation is specific to usage prices - subscription/single_payment can use any slug
.refine((data) => !isReservedPriceSlug(data.slug ?? ''), {
  message: 'Usage price slugs ending with "_no_charge" are reserved for auto-generated fallback prices',
})
```

This validation in `setupSchemas.ts` covers the **pricing.yaml** path since that's where YAML input is validated.

**File:** `src/db/schema/prices.ts`

Add the same validation to the **usage price** insert schema only:

```ts
// In the usage price discriminated union insert schema:
// Only usage prices have the reserved slug restriction
.refine((data) => !isReservedPriceSlug(data.slug ?? ''), {
  message: 'Usage price slugs ending with "_no_charge" are reserved for auto-generated fallback prices',
})
```

**File:** `src/server/routers/pricesRouter.ts`

Add validation in the create handler to reject reserved slugs **for usage prices only**:

```ts
if (input.price.type === PriceType.Usage && input.price.slug?.endsWith('_no_charge')) {
  throw new TRPCError({
    code: 'BAD_REQUEST',
    message: 'Usage price slugs ending with "_no_charge" are reserved for auto-generated fallback prices',
  })
}
```

**Note:** The `_no_charge` suffix is only reserved for usage prices. Subscription and single_payment prices can use any slug.

---

### Patch 2: Auto-Create No Charge Price on Usage Meter Creation

**File:** `src/utils/usage/noChargePriceHelpers.ts` (new file)

Create helper functions for no charge price logic:

```ts
export const getNoChargeSlugForMeter = (usageMeterSlug: string): string => {
  return `${usageMeterSlug}_no_charge`
}

export const isNoChargePrice = (priceSlug: string): boolean => {
  return priceSlug.endsWith('_no_charge')
}

export const createNoChargePriceInsert = (
  usageMeter: UsageMeter.Record,
  organizationId: string
): Price.Insert => ({
  type: PriceType.Usage,
  name: `${usageMeter.name} - No Charge`,
  slug: getNoChargeSlugForMeter(usageMeter.slug),
  usageMeterId: usageMeter.id,
  pricingModelId: usageMeter.pricingModelId,
  productId: null,
  unitPrice: 0,
  usageEventsPerUnit: 1,
  isDefault: true, // Default until another price is set as default
  active: true,
  organizationId,
  intervalUnit: null,
  intervalCount: null,
  trialPeriodDays: null,
  setupFeeAmount: null,
})
```

**File:** `src/db/tableMethods/usageMeterMethods.ts`

Update `insertUsageMeter` to also create the no charge price:

```ts
export const insertUsageMeterWithNoChargePrice = async (
  usageMeter: UsageMeter.Insert,
  organizationId: string,
  transaction: DbTransaction
): Promise<{ usageMeter: UsageMeter.Record; noChargePrice: Price.Record }> => {
  const insertedMeter = await insertUsageMeter(usageMeter, transaction)
  const noChargePriceInsert = createNoChargePriceInsert(insertedMeter, organizationId)
  const noChargePrice = await insertPrice(noChargePriceInsert, transaction)
  return { usageMeter: insertedMeter, noChargePrice }
}
```

**File:** `src/utils/pricingModels/setupTransaction.ts` (~line 83)

After creating usage meters in `setupPricingModelTransaction`, create no charge prices for each:

```ts
// After bulk inserting usage meters:
const insertedUsageMeters = await bulkInsertOrDoNothingUsageMetersBySlugAndPricingModelId(...)

// Create no charge prices for each new usage meter
const noChargePriceInserts = insertedUsageMeters.map((meter) =>
  createNoChargePriceInsert(meter, organizationId)
)
await bulkInsertPrices(noChargePriceInserts, transaction)
```

---

### Patch 3: Default Price Cascade Logic

When a price is updated to remove `isDefault`, or when the current default is deactivated, the no_charge price should become the new default. When setting a new price as default, the previous default must be automatically unset.

**File:** `src/db/tableMethods/priceMethods.ts`

Add helper to unset all other usage prices for a meter when setting one as default:

```ts
export const setPricesForUsageMeterToNonDefault = async (
  usageMeterId: string,
  transaction: DbTransaction
): Promise<void> => {
  await transaction.db
    .update(prices)
    .set({ isDefault: false })
    .where(and(
      eq(prices.usageMeterId, usageMeterId),
      eq(prices.isDefault, true)
    ))
}
```

Update `safelyUpdatePrice` to handle usage prices (currently only handles product prices):

```ts
export const safelyUpdatePrice = async (
  price: Price.Update,
  transaction: DbTransaction
) => {
  if (price.isDefault) {
    const existingPrice = await selectPriceById(price.id, transaction)
    // For product prices, reset other prices for the same product
    if (Price.hasProductId(existingPrice)) {
      await setPricesForProductToNonDefault(existingPrice.productId, transaction)
    }
    // For usage prices, reset other prices for the same usage meter
    if (existingPrice.type === PriceType.Usage && existingPrice.usageMeterId) {
      await setPricesForUsageMeterToNonDefault(existingPrice.usageMeterId, transaction)
    }
  }
  return updatePrice(price, transaction)
}
```

Add helper to get or set the no charge price as default:

```ts
export const ensureUsageMeterHasDefaultPrice = async (
  usageMeterId: string,
  transaction: DbTransaction
): Promise<void> => {
  // Check if meter has any default price
  const defaultPrice = await selectDefaultPriceForUsageMeter(usageMeterId, transaction)
  if (defaultPrice) return

  // Set the no_charge price as default
  const usageMeter = await selectUsageMeterById(usageMeterId, transaction)
  if (!usageMeter) throw new Error(`Usage meter ${usageMeterId} not found`)

  const noChargeSlug = getNoChargeSlugForMeter(usageMeter.slug)
  await updatePriceBySlugAndPricingModelId(
    noChargeSlug,
    usageMeter.pricingModelId,
    { isDefault: true },
    transaction
  )
}

export const selectDefaultPriceForUsageMeter = async (
  usageMeterId: string,
  transaction: DbTransaction
): Promise<Price.Record | null> => {
  const result = await transaction.db
    .select()
    .from(prices)
    .where(and(
      eq(prices.usageMeterId, usageMeterId),
      eq(prices.isDefault, true),
      eq(prices.active, true)
    ))
    .limit(1)
  return result[0] ?? null
}
```

**File:** `src/server/routers/pricesRouter.ts`

In the `updatePrice` procedure, after updating a usage price to `isDefault: false`:

```ts
// After the price update succeeds:
if (existingPrice.type === PriceType.Usage && input.price.isDefault === false) {
  await ensureUsageMeterHasDefaultPrice(existingPrice.usageMeterId!, transaction)
}
```

---

### Patch 4: Use Default Price When Creating Usage Events by Meter Identifier

**File:** `src/utils/usage/usageEventHelpers.ts` (~line 254)

Update `resolveUsageEventInput()` to use the default price when meter identifier is provided:

```ts
// When usageMeterId or usageMeterSlug is provided:
const defaultPrice = await selectDefaultPriceForUsageMeter(usageMeterId, transaction)
if (!defaultPrice) {
  throw new TRPCError({
    code: 'INTERNAL_SERVER_ERROR',
    message: `Usage meter ${usageMeterId} has no default price. This should not happen.`,
  })
}
return {
  priceId: defaultPrice.id,
  usageMeterId,
}
```

**File:** `src/utils/usage/bulkInsertUsageEventsTransaction.ts` (~line 243)

Update slug resolution to also resolve to the default price:

```ts
// When resolving usageMeterSlug:
const meter = usageMetersBySlug.get(usageMeterSlug)
if (!meter) throw new Error(`Usage meter with slug ${usageMeterSlug} not found`)

const defaultPrice = await selectDefaultPriceForUsageMeter(meter.id, transaction)
if (!defaultPrice) {
  throw new Error(`Usage meter ${usageMeterSlug} has no default price`)
}

return {
  priceId: defaultPrice.id,
  usageMeterId: meter.id,
}
```

---

### Patch 5: Backfill No Charge Prices for Existing Usage Meters

**File:** `src/scripts/backfillNoChargePrices.ts` (new file)

Create a backfill script that:

1. Queries all usage meters
2. For each meter, checks if a `{slug}_no_charge` price exists
3. If not, creates one with the standard no charge configuration
4. If no other price on the meter is `isDefault: true`, sets the no_charge price as default

```ts
export const backfillNoChargePrices = async () => {
  const allUsageMeters = await selectAllUsageMeters()

  for (const meter of allUsageMeters) {
    await adminTransaction(async ({ transaction }) => {
      const noChargeSlug = getNoChargeSlugForMeter(meter.slug)
      const existingNoChargePrice = await selectPriceBySlugAndPricingModelId(
        noChargeSlug,
        meter.pricingModelId,
        transaction
      )

      if (existingNoChargePrice) return // Already exists

      // Check if meter has any default price
      const hasDefaultPrice = await selectDefaultPriceForUsageMeter(meter.id, transaction)

      const noChargePriceInsert = createNoChargePriceInsert(meter, meter.organizationId)
      // Only set as default if no other default exists
      noChargePriceInsert.isDefault = !hasDefaultPrice

      await insertPrice(noChargePriceInsert, transaction)
    })
  }
}
```

---

## Acceptance Criteria

- [ ] Every usage meter has a `{usagemeterslug}_no_charge` price auto-created
- [ ] The `_no_charge` slug suffix is reserved for **usage prices only** and rejected in user input (UI, API, YAML)
- [ ] Subscription and single_payment prices can still use `_no_charge` suffix (no restriction)
- [ ] When creating usage events with `usageMeterId` or `usageMeterSlug`, the default price is used
- [ ] Usage events can no longer be created without a price (all events have `priceId` set)
- [ ] When the current default price is unset, the no_charge price becomes the default
- [ ] When setting price B as default, price A is automatically unset (no cascade to no_charge)
- [ ] Users can set any price (including non-$0 prices) as the default
- [ ] No charge prices cannot be archived/deleted (protected)
- [ ] No charge prices: only `name` is editable; `slug` and `unitPrice=0` are immutable
- [ ] Backfill script creates no_charge prices for all existing usage meters
- [ ] Existing priceless usage events are left as-is for historical accuracy
- [ ] EditUsagePriceModal has `isDefault` switch (similar to `active` switch)
- [ ] EditUsagePriceModal disables both `isDefault` and `active` switches for `_no_charge` prices
- [ ] All existing tests pass
- [ ] New test coverage for all patches

---

## Decisions (Resolved)

1. **No_charge prices cannot be archived/deleted.** They are protected and always exist as a fallback.
2. **No_charge prices are partially editable.** Only `name` can be edited. The `slug` and `unitPrice=0` are immutable.
3. **Existing priceless usage events are left as-is.** For historical accuracy, we don't backfill existing events. New events will always have a priceId.

---

## Explicit Opinions

1. **Reserved slug pattern (usage prices only)**: The `_no_charge` suffix is reserved for usage prices only. Subscription and single_payment prices can use any slug including `_no_charge` suffix. This allows the pattern to work with any usage meter slug (e.g., `api_requests_no_charge`, `storage_gb_no_charge`).

2. **Default cascade to no_charge only when no default remains**: The no_charge price becomes default **only** when no other price is marked as default. Specifically:
   - If price A is default and user sets price B as default → A is unset, B becomes default, no_charge stays non-default
   - If price A is default and user unsets A without setting another → no_charge becomes default
   - The cascade happens only when the meter would otherwise have no default

3. **No_charge price is always $0**: The no_charge price is always `unitPrice: 0, usageEventsPerUnit: 1`. This is the definition of "no charge" and should be immutable. Only the `name` field can be edited.

4. **No_charge prices are protected**: They cannot be archived or deleted. They exist as long as the usage meter exists.

5. **Usage events always have a price after this lands**: By using the default price when meter identifier is provided, we eliminate priceless usage events. This is a behavioral change but simplifies billing logic significantly.

6. **Existing priceless events left as-is**: For historical accuracy and to avoid retroactive billing changes, existing usage events with `priceId: null` are not backfilled. Only new events will always have a priceId.

7. **Backfill is safe**: Creating no_charge prices for existing meters doesn't affect existing subscriptions or billing. It just provides a fallback that didn't exist before.

8. **No_charge in pricing.yaml is rejected**: Users cannot specify `_no_charge` usage prices in `pricing.yaml`. The validation in `setupSchemas.ts` rejects any usage price with a slug ending in `_no_charge`. These prices are auto-generated and managed by the system.

---

## Patches

### Patch 1: Reserved Slug Validation

**Files to modify:**
- `src/utils/pricingModels/setupSchemas.ts` (covers pricing.yaml validation)
- `src/db/schema/prices.ts`
- `src/server/routers/pricesRouter.ts`

**Changes:**
1. Add `isReservedPriceSlug()` helper function
2. Add Zod refinement to reject `_no_charge` suffix in usage price slugs
3. Add API validation in pricesRouter

**Test cases:**
```ts
describe('reserved slug validation (usage prices only)', () => {
  it('rejects usage price creation with _no_charge suffix via API', async () => {
    // setup: call prices.create with type: usage, slug: "my_price_no_charge"
    // expect: 400 error with message about reserved slug
  })

  it('rejects usage price creation with _no_charge suffix in setupPricingModel', async () => {
    // setup: call setupPricingModel with a usage price having slug ending in _no_charge
    // expect: validation error about reserved slug
  })

  it('allows usage price creation with slug not ending in _no_charge', async () => {
    // setup: call prices.create with type: usage, slug: "my_custom_price"
    // expect: success, price created
  })

  it('allows subscription price creation with _no_charge suffix', async () => {
    // setup: call prices.create with type: subscription, slug: "promo_no_charge"
    // expect: success, price created (restriction only applies to usage prices)
  })

  it('allows single_payment price creation with _no_charge suffix', async () => {
    // setup: call prices.create with type: single_payment, slug: "trial_no_charge"
    // expect: success, price created (restriction only applies to usage prices)
  })

  it('rejects the exact suffix pattern not just containing _no_charge', async () => {
    // setup: usage price slugs like "no_charge_extra" should be allowed
    // expect: "no_charge_extra" succeeds for usage price, "extra_no_charge" fails for usage price
  })
})
```

---

### Patch 2: Auto-Create No Charge Price on Usage Meter Creation

**Files to create:**
- `src/utils/usage/noChargePriceHelpers.ts`

**Files to modify:**
- `src/db/tableMethods/usageMeterMethods.ts`
- `src/utils/pricingModels/setupTransaction.ts`

**Changes:**
1. Create `noChargePriceHelpers.ts` with slug generation and insert helpers
2. Update `insertUsageMeter` to optionally create no charge price
3. Update `setupPricingModelTransaction` to create no charge prices after meters

**Test cases:**
```ts
describe('auto-create no charge price', () => {
  describe('single usage meter creation', () => {
    it('creates a no_charge price when creating a usage meter', async () => {
      // setup: create a usage meter with slug "api_requests"
      // expect:
      // - usage meter created
      // - price with slug "api_requests_no_charge" exists
      // - price has unitPrice: 0, usageEventsPerUnit: 1
      // - price has isDefault: true
      // - price has productId: null
      // - price has correct pricingModelId from meter
    })
  })

  describe('setupPricingModel with usage meters', () => {
    it('creates no_charge prices for all usage meters in pricing model setup', async () => {
      // setup: setupPricingModel with 2 usage meters: "api_calls", "storage"
      // expect:
      // - "api_calls_no_charge" price exists with isDefault: true
      // - "storage_no_charge" price exists with isDefault: true
    })

    it('sets no_charge as default only if no other price specified as default', async () => {
      // setup: setupPricingModel with usage meter and a custom price with isDefault: true
      // expect:
      // - no_charge price exists but isDefault: false
      // - custom price has isDefault: true
    })
  })
})
```

---

### Patch 3: Default Price Cascade Logic & No Charge Protection

**Files to modify:**
- `src/db/tableMethods/priceMethods.ts`
- `src/server/routers/pricesRouter.ts`

**Changes:**
1. Add `setPricesForUsageMeterToNonDefault()` helper (mirrors `setPricesForProductToNonDefault`)
2. Update `safelyUpdatePrice` to handle usage prices (unset other meter prices when setting one as default)
3. Add `selectDefaultPriceForUsageMeter()` helper
4. Add `ensureUsageMeterHasDefaultPrice()` helper
5. Update `updatePrice` to cascade default to no_charge when needed
6. Add protection: reject archive/delete of no_charge prices
7. Add protection: reject changes to `unitPrice` or `slug` on no_charge prices (only `name` editable)

**Test cases:**
```ts
describe('default price cascade', () => {
  it('sets no_charge as default when current default is explicitly unset', async () => {
    // setup:
    // - usage meter with no_charge price (isDefault: false)
    // - price A with isDefault: true
    // action: update price A to isDefault: false (without setting another as default)
    // expect:
    // - price A has isDefault: false
    // - no_charge price now has isDefault: true
  })

  it('sets no_charge as default when current default is deactivated', async () => {
    // setup:
    // - usage meter with no_charge price (isDefault: false)
    // - price A with isDefault: true, active: true
    // action: update price A to active: false
    // expect:
    // - price A has active: false
    // - no_charge price now has isDefault: true
  })

  it('does NOT cascade to no_charge when setting another price as default', async () => {
    // setup:
    // - usage meter with no_charge price (isDefault: false)
    // - price A with isDefault: true
    // - price B with isDefault: false
    // action: update price B to isDefault: true
    // expect:
    // - price A is automatically unset (isDefault: false)
    // - price B is default (isDefault: true)
    // - no_charge remains isDefault: false (no cascade triggered)
  })

  it('automatically unsets the previous default when setting a new default', async () => {
    // setup:
    // - price A with isDefault: true
    // - price B with isDefault: false
    // action: update price B to isDefault: true
    // expect:
    // - price A has isDefault: false (automatically unset)
    // - price B has isDefault: true
    // - database unique constraint is maintained (only one default per meter)
  })

  it('keeps existing default when no_charge is created for meter with prices', async () => {
    // setup: backfill scenario - meter has price X with isDefault: true
    // action: create no_charge price for meter
    // expect:
    // - price X remains default (isDefault: true)
    // - no_charge is isDefault: false
  })
})

describe('no_charge price protection', () => {
  it('rejects archiving a no_charge price', async () => {
    // setup: usage meter with no_charge price
    // action: attempt to update no_charge price to active: false
    // expect: 400 error with message about no_charge prices being protected
  })

  it('rejects deleting a no_charge price', async () => {
    // setup: usage meter with no_charge price
    // action: attempt to delete no_charge price
    // expect: 400 error with message about no_charge prices being protected
  })

  it('rejects changing unitPrice on no_charge price', async () => {
    // setup: usage meter with no_charge price (unitPrice: 0)
    // action: attempt to update no_charge price to unitPrice: 100
    // expect: 400 error with message about unitPrice being immutable on no_charge prices
  })

  it('rejects changing slug on no_charge price', async () => {
    // setup: usage meter with no_charge price (slug: "meter_no_charge")
    // action: attempt to update no_charge price slug
    // expect: 400 error with message about slug being immutable on no_charge prices
  })

  it('allows changing name on no_charge price', async () => {
    // setup: usage meter with no_charge price (name: "Meter - No Charge")
    // action: update no_charge price name to "Free Usage"
    // expect: success, name updated
  })
})
```

---

### Patch 4: Use Default Price When Creating Usage Events by Meter Identifier

**Files to modify:**
- `src/utils/usage/usageEventHelpers.ts`
- `src/utils/usage/bulkInsertUsageEventsTransaction.ts`

**Changes:**
1. Update `resolveUsageEventInput()` to fetch and use default price
2. Update bulk insert slug resolution to use default price
3. All usage events now have `priceId` set

**Test cases:**
```ts
describe('usage events use default price', () => {
  it('resolves usageMeterId to the default price', async () => {
    // setup: usage meter with no_charge as default
    // action: create usage event with usageMeterId (no priceId)
    // expect:
    // - event created successfully
    // - event.priceId equals no_charge price id
    // - event.usageMeterId equals the meter id
  })

  it('resolves usageMeterSlug to the default price', async () => {
    // setup: usage meter "api_calls" with custom default price
    // action: create usage event with usageMeterSlug: "api_calls"
    // expect: event.priceId equals the custom default price id
  })

  it('bulk insert resolves all meter identifiers to default prices', async () => {
    // setup: 2 meters with different default prices
    // action: bulk insert events using both usageMeterSlug values
    // expect: each event has the correct priceId for its meter's default
  })

  it('throws error if meter somehow has no default price', async () => {
    // setup: (edge case) meter with no default price (should not happen)
    // action: try to create usage event with usageMeterId
    // expect: internal server error about missing default price
  })
})
```

---

### Patch 5: Backfill No Charge Prices for Existing Usage Meters

**Files to create:**
- `src/scripts/backfillNoChargePrices.ts`

**Changes:**
1. Create backfill script that iterates all usage meters
2. Creates no_charge price if missing
3. Sets as default only if no other default exists

**Test cases:**
```ts
describe('backfill no charge prices', () => {
  it('creates no_charge price for meter with no prices', async () => {
    // setup: usage meter with no prices
    // action: run backfill
    // expect: no_charge price created with isDefault: true
  })

  it('creates no_charge price for meter with prices but no default', async () => {
    // setup: usage meter with prices but all isDefault: false
    // action: run backfill
    // expect: no_charge price created with isDefault: true
  })

  it('creates no_charge price with isDefault: false if meter has existing default', async () => {
    // setup: usage meter with price X having isDefault: true
    // action: run backfill
    // expect: no_charge price created with isDefault: false
  })

  it('skips meters that already have no_charge price', async () => {
    // setup: meter with existing no_charge price
    // action: run backfill
    // expect: no duplicate created, original no_charge unchanged
  })

  it('handles all meters in a large dataset', async () => {
    // setup: 100 usage meters with various states
    // action: run backfill
    // expect: all meters have exactly one no_charge price
  })
})
```

---

### Patch 6: UI Changes for Default Price Management

**Files to modify:**
- `src/components/forms/EditUsagePriceModal.tsx`

**Changes:**
1. Add `isDefault` switch to EditUsagePriceModal (similar to existing `active` switch)
2. For `_no_charge` prices, disable both switches (`active` and `isDefault`)
3. When `isDefault` is toggled on, call `safelyUpdatePrice` which handles unsetting other defaults
4. When `isDefault` is toggled off, trigger cascade to set no_charge as default

**Implementation:**

```tsx
// In UsagePriceFormFields component, add after the Status (active) switch:

{/* Default Price toggle */}
<FormField
  control={form.control}
  name="price.isDefault"
  render={({ field }) => (
    <FormItem>
      <FormLabel>Default Price</FormLabel>
      <FormControl>
        <div className="flex items-center space-x-2">
          <Switch
            id="price-isDefault"
            checked={field.value}
            onCheckedChange={field.onChange}
            disabled={isNoChargePrice(price.slug)}
          />
          <Label htmlFor="price-isDefault" className="cursor-pointer w-full">
            {field.value ? 'Default' : 'Not Default'}
          </Label>
        </div>
      </FormControl>
      <FormDescription>
        The default price is used when usage events are created with just the meter identifier.
        {isNoChargePrice(price.slug) && ' No charge prices are always available as the fallback default.'}
      </FormDescription>
      <FormMessage />
    </FormItem>
  )}
/>

// Also disable the active switch for no_charge prices:
<Switch
  id="price-active"
  checked={field.value}
  onCheckedChange={field.onChange}
  disabled={isNoChargePrice(price.slug)}
/>
```

**Test cases:**
```ts
describe('EditUsagePriceModal isDefault switch', () => {
  it('renders isDefault switch for regular usage prices', async () => {
    // setup: render modal with regular usage price
    // expect: isDefault switch is visible and enabled
  })

  it('disables isDefault switch for no_charge prices', async () => {
    // setup: render modal with no_charge price (slug ends with _no_charge)
    // expect: isDefault switch is visible but disabled
  })

  it('disables active switch for no_charge prices', async () => {
    // setup: render modal with no_charge price
    // expect: active switch is visible but disabled
  })

  it('allows toggling isDefault on for regular usage prices', async () => {
    // setup: render modal with non-default usage price
    // action: toggle isDefault switch on
    // expect: form value updates, submit triggers safelyUpdatePrice
  })

  it('allows toggling isDefault off for regular usage prices', async () => {
    // setup: render modal with default usage price (not no_charge)
    // action: toggle isDefault switch off
    // expect: form value updates, submit triggers cascade to no_charge
  })
})
```

---

## Dependency Graph

```
- Patch 1 -> []
- Patch 2 -> [1]
- Patch 3 -> [2]
- Patch 4 -> [2, 3]
- Patch 5 -> [2, 3]
- Patch 6 -> [2, 3]
```

**Notes:**
- Patch 1 (reserved slug validation) is independent and can land first
- Patch 2 (auto-create) depends on Patch 1 to ensure reserved slugs are enforced before auto-creation
- Patch 3 (cascade logic) depends on Patch 2 because it needs the no_charge price to exist
- Patch 4 (use default price) depends on Patches 2 and 3 because it relies on default price existing
- Patch 5 (backfill) depends on Patches 2 and 3 to use the same helpers
- Patch 6 (UI changes) depends on Patches 2 and 3 because it needs no_charge detection and cascade logic

**Relationship to GAMEPLAN_DATA_MODEL_PRICES-2-1.md:**

This gameplan should be executed **after** PR 1 from the existing gameplan lands (schema changes making `productId` nullable for usage prices). The no_charge prices created here will have `productId: null` as expected.

Specifically:
- PR 1 from existing gameplan (schema changes) must land first
- Then Patches 1-6 from this gameplan can be executed
- This replaces PR 8 and PR 9 from the existing gameplan (auto-create and backfill)
