---
title: "Auth"
description: "Learn how to set up Flowglad server client using your auth provider of choice"
---

Flowglad provides flexible authentication integration that works with any auth provider. You have complete control over how you define your customers, whether you're building a B2C app with individual users or a B2B platform with organization customers.

## Scoped Server Pattern (Recommended)

The scoped server pattern gives you maximum flexibility for defining customers and works seamlessly with any authentication provider. This approach uses a factory function that creates a `FlowgladServer` instance scoped to a specific customer.

**Key benefits:**
- Works with any auth provider
- Full control over customer identity (user ID for B2C, organization ID for B2B)

### Server Setup

Create a Flowglad server factory function in a shared file (e.g., `utils/flowglad.ts`):

<CodeGroup>

```ts Better Auth
import { FlowgladServer } from '@flowglad/nextjs/server'
import { auth } from '@/utils/auth'
import { headers } from 'next/headers'

export const flowglad = (customerExternalId: string) => {
  return new FlowgladServer({
    customerExternalId,
    getCustomerDetails: async (customerExternalId) => {
      const session = await auth.api.getSession({
        headers: await headers(),
      })
      if (!session?.user) {
        throw new Error('User not authenticated')
      }
      return {
        email: session.user.email || '',
        name: session.user.name || ''
      }
    },
  })
}
```

```ts Supabase Auth
import { FlowgladServer } from '@flowglad/nextjs/server'
import { createClient } from '@/utils/supabase/server'

export const flowglad = (customerExternalId: string) => {
  return new FlowgladServer({
    customerExternalId,
    getCustomerDetails: async (customerExternalId) => {
      const supabase = await createClient()
      const { data: { user } } = await supabase.auth.getUser()
      if (!user) {
        throw new Error('User not authenticated')
      }
      return {
        email: user.email || '',
        name: user.user_metadata.name || user.email || ''
      }
    },
  })
}
```

```ts B2B (Organization-based)
import { FlowgladServer } from '@flowglad/nextjs/server'

export const flowglad = (organizationId: string) => {
  // For B2B apps: organizationId is ID from YOUR app's database
  return new FlowgladServer({
    customerExternalId: organizationId,
    getCustomerDetails: async (customerExternalId) => {
      // Fetch organization details from YOUR database using YOUR org ID
      const org = await db.organizations.findOne({ id: customerExternalId })
      if (!org) {
        throw new Error('Organization not found')
      }
      return {
        email: org.billingEmail || org.ownerEmail,
        name: org.name,
      }
    },
  })
}
```

</CodeGroup>

<Note>
**Important:** `customerExternalId` is the ID from **your app's database** (e.g., `user.id` or `organization.id`), **not** Flowglad's customer ID.

**B2C apps:** Pass `user.id` as `customerExternalId`  
**B2B apps:** Pass `organization.id` or `team.id` as `customerExternalId`
</Note>

### Next Route Handler Setup

Set up your Flowglad API route at `/api/flowglad/[...path]` to handle requests from your frontend:

<CodeGroup>

```ts Better Auth
import { nextRouteHandler } from '@flowglad/nextjs/server'
import { flowglad } from '@/utils/flowglad'
import { auth } from '@/utils/auth'
import { headers } from 'next/headers'

export const { GET, POST } = nextRouteHandler({
  flowglad,
  getCustomerExternalId: async (req) => {
    const session = await auth.api.getSession({
      headers: await headers(),
    })
    const userId = session?.user?.id
    if (!userId) {
      throw new Error('User not found')
    }
    return userId
  },
})
```

```ts Supabase Auth
import { nextRouteHandler } from '@flowglad/nextjs/server'
import { flowglad } from '@/utils/flowglad'
import { createClient } from '@/utils/supabase/server'

export const { GET, POST } = nextRouteHandler({
  flowglad,
  getCustomerExternalId: async (req) => {
    const supabase = await createClient()
    const {
      data: { user }
    } = await supabase.auth.getUser()
    const userId = user?.id
    if (!userId) {
      throw new Error('User not found')
    }
    return userId
  },
})
```

```ts Clerk
import { nextRouteHandler } from '@flowglad/nextjs/server'
import { flowglad } from '@/utils/flowglad'
import { currentUser } from '@clerk/nextjs/server'

export const { GET, POST } = nextRouteHandler({
  flowglad,
  getCustomerExternalId: async (req) => {
    const user = await currentUser()
    const userId = user?.id
    if (!userId) {
      throw new Error('User not found')
    }
    return userId
  },
})
```

```ts Next Auth
import { nextRouteHandler } from '@flowglad/nextjs/server'
import { flowglad } from '@/utils/flowglad'
import { auth } from '@/auth'

export const { GET, POST } = nextRouteHandler({
  flowglad,
  getCustomerExternalId: async (req) => {
    const session = await auth()
    const userId = session?.user?.id
    if (!userId) {
      throw new Error('User not found')
    }
    return userId
  },
})
```

</CodeGroup>

## Legacy Auth Adapters Pattern

The auth adapters pattern was our previous approach for integrating authentication. It has built-in adapters for popular auth providers and supports custom auth, but has less flexibility for B2B business models with organization customers.

**Built-in adapters:**
- `betterAuth` - Better Auth integration
- `supabaseAuth` - Supabase Auth integration
- `clerk` - Clerk integration
- `nextAuth` - Next Auth integration
- `getRequestingCustomer` - Custom session loader for any provider

### Adapter Examples

<CodeGroup>

```ts Better Auth
import { auth } from '@/lib/auth'
import { headers } from 'next/headers'
import { FlowgladServer } from '@flowglad/nextjs/server'

export const flowgladServer = new FlowgladServer({
  betterAuth: {
    getSession: async () => auth.api.getSession({ headers: await headers() }),
  },
})
```

```ts Supabase Auth
import { FlowgladServer } from '@flowglad/nextjs/server'
import { createClient } from '@/utils/supabase'

export const flowgladServer = new FlowgladServer({
  supabaseAuth: {
    // this must be the supabase server client
    client: createClient,
  },
})
```

```ts Clerk
import { currentUser } from '@clerk/nextjs/server'
import { FlowgladServer } from '@flowglad/nextjs/server'

export const flowgladServer = new FlowgladServer({
  clerk: {
    currentUser,
  },
})
```

```ts Next Auth
import { auth } from '@/auth'
import { FlowgladServer } from '@flowglad/nextjs/server'

export const flowgladServer = new FlowgladServer({
  nextAuth: {
    auth,
  },
})
```

```ts Custom Adapters
// Example 1: Custom Session Loader
import { FlowgladServer } from '@flowglad/nextjs/server'
import { getBespokeSession } from '@/utils/auth'

export const flowgladServer = new FlowgladServer({
  getRequestingCustomer: async () => {
    const session = await getBespokeSession()
    if (!session) return null

    return {
      externalId: session.id,
      name: session.name,
      email: session.email,
    }
  },
})

// Example 2: Custom with Request
import { FlowgladServer } from '@flowglad/nextjs/server'
import { getBespokeSession } from '@/utils/auth'

export const createFlowgladServer = (request: Request) =>
  new FlowgladServer({
    getRequestingCustomer: async () => {
      const session = await getBespokeSession(request)
      if (!session) return null

      return {
        externalId: session.id,
        name: session.name,
        email: session.email,
      }
    },
  })

// Example 3: Firebase
import { FlowgladServer } from '@flowglad/server'
import admin from 'firebase-admin'

admin.initializeApp()

export const flowgladServer = (request: Request) =>
  new FlowgladServer({
    getRequestingCustomer: async () => {
      const token = request.headers.get('authorization')?.replace('Bearer ', '')

      if (!token) return null

      try {
        const decodedToken = await admin.auth().verifyIdToken(token)

        return {
          externalId: decodedToken.uid,
          name: decodedToken.name || decodedToken.email!,
          email: decodedToken.email!,
        }
      } catch (error) {
        return null
      }
    }
  })
```

</CodeGroup>

## Which Pattern Should I Use?

**Use the Scoped Server Pattern if:**
- You want maximum flexibility
- You need to support B2B use cases
- You want explicit control over customer identity
- You're starting a new integration

**Use the Legacy Adapters Pattern if:**
- You have an existing integration using adapters
- You prefer a simpler setup for basic use cases
- Your auth provider has a built-in adapter
