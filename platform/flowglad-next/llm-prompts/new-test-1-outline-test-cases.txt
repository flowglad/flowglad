# Planning Test Cases
This is a guide designed to help you complete the first step in writing a comprehensive test suite: planning the tests.

Here are some brief instructions on how to do this step:

## 1. Examine the Code

Consider every condition implied by the code. If the code uses functions that are found elsewhere -- either in the file or in other files -- go check those files out. And do so recursively if necessary. Your initial goal is to fully understand what this code does.

Don't just rely on the code but also take hints from the comments.

## 2. Enumerate all of the scenarios where its behavior will differ

Oftentimes it is easier to think about the code in terms of different conditions - different sets of arguments for example, that each function might receive - and how that would change the function's behavior.

Once you have a good sense of all of the possible scenarios for a given passage of code, list them out. These will make for great test conditions.

## 3. Write out your plan

In a markdown format, come up with a list of test cases. These test cases should include what will be required to set up the state necessary for the test case, as well as the expectations that we should assert at the end of each test.

Ideally, your test cases are separated by scenario. The gameplan is that each of these scenarios will be later tested in a vitest suite like so:
```ts
describe("thefunction", ()=> { it("should [do X] when [condition Y]", () => {...})})
```

Do these steps for each function in the file that we want to test. If one function in the file consumes another function, you should write out test cases for both functions.

Remember - don't write the actual code for the test. This step is all about coming up with a gameplan. Give it some thought, and once you feel like you have a good gameplan, write out the list of cases.

## Notes
There will be a strong temptation to test functionality in the database layer. For now, you should not see that as your job. Instead, you should just test functionality assuming the database is an always-working data store. 

So things like "will roll back in the case that the transaction fails" - those do nothing for us. Do not include them.

In the case where we planning on tests in a file for db/tableMethods or db/schema - there, it can make sense to write tests that assert certain database functionality - such as uniqueness constraints, foreign key constraints, and RLS policies.

But outside of the src/db directory - there's really no reason to test things that happen at the database layer. Instead you should see that layer as an opaque implementation detail.

# Test Case Plan for Usage Overages in BillingRunHelpers

This document outlines additional test cases needed to ensure robust coverage for the `usageOverages` functionality within `billingRunHelpers.ts`.

## 1. `billingPeriodItemsToInvoiceLineItemInserts`

This function translates `BillingPeriodItem.Record[]` into `InvoiceLineItem.Insert[]`, now considering `usageOverages`.

### Scenario 1.1: No usage overages (existing behavior confirmation)
*   **Setup:**
    *   `billingPeriodItems`: An array containing items of type `SubscriptionItemType.Static` and `SubscriptionItemType.Usage`.
    *   `usageOverages`: An empty array `[]`.
*   **Expectations:**
    *   Invoice line items are generated for all `billingPeriodItems`.
    *   For `billingPeriodItems` of type `SubscriptionItemType.Usage`, the `quantity` in the resulting `InvoiceLineItem.Insert` should be `0`.
    *   For `billingPeriodItems` of type `SubscriptionItemType.Static`, the `quantity` should be as specified in the `billingPeriodItem`.

### Scenario 1.2: With usage overages for a `Usage` type `BillingPeriodItem`
*   **Setup:**
    *   `billingPeriodItems`: Includes at least one item of type `SubscriptionItemType.Usage` with a specific `usageMeterId` and a positive `usageEventsPerUnit`.
    *   `usageOverages`: Contains an object matching the `usageMeterId` of the `Usage` type item, with a positive `balance`.
*   **Expectations:**
    *   The `InvoiceLineItem.Insert` corresponding to the `Usage` type `billingPeriodItem` has `quantity = usageOverage.balance / billingPeriodItem.usageEventsPerUnit`.
    *   Other static line items are unaffected.

### Scenario 1.3: Usage overage with zero balance
*   **Setup:**
    *   Similar to Scenario 1.2, but the `balance` in the `usageOverage` object is `0`.
*   **Expectations:**
    *   The `quantity` for the corresponding `Usage` type `InvoiceLineItem.Insert` is `0`.

### Scenario 1.4: `Usage` type `BillingPeriodItem` with `usageEventsPerUnit` as null
*   **Setup:**
    *   `billingPeriodItems`: Includes a `Usage` type item with `usageEventsPerUnit = null`.
    *   `usageOverages`: Contains a matching `usageOverage` with a positive `balance`.
*   **Expectations:**
    *   The `quantity` for the corresponding `Usage` type `InvoiceLineItem.Insert` is `0`.

### Scenario 1.5: `Usage` type `BillingPeriodItem` with `usageEventsPerUnit` as zero
*   **Setup:**
    *   `billingPeriodItems`: Includes a `Usage` type item with `usageEventsPerUnit = 0`.
    *   `usageOverages`: Contains a matching `usageOverage` with a positive `balance`.
*   **Expectations:**
    *   The `quantity` for the corresponding `Usage` type `InvoiceLineItem.Insert` is `0`.

### Scenario 1.6: Usage overage present, but no matching `Usage` type `BillingPeriodItem`
*   **Setup:**
    *   `usageOverages`: Contains an entry for a `usageMeterId`.
    *   `billingPeriodItems`: Does *not* contain any `Usage` type item with that `usageMeterId`.
*   **Expectations:**
    *   The specific `usageOverage` is ignored. No extra line item is created for it.
    *   Line items are generated based only on the provided `billingPeriodItems`.

### Scenario 1.7: `Usage` type `BillingPeriodItem` present, but no matching usage overage
*   **Setup:**
    *   `billingPeriodItems`: Includes a `Usage` type item.
    *   `usageOverages`: Is an empty array or does not contain an entry for the `usageMeterId` of the item.
*   **Expectations:**
    *   The `quantity` for the corresponding `Usage` type `InvoiceLineItem.Insert` is `0`.

## 2. `calculateFeeAndTotalAmountDueForBillingPeriod`

This function calculates fees and the total amount due, now passing `usageOverages` to `createAndFinalizeSubscriptionFeeCalculation`.

### Scenario 2.1: No usage overages (existing behavior confirmation)
*   **Setup:**
    *   Standard `billingPeriod`, `billingPeriodItems`, `organization`, `paymentMethod`.
    *   `usageOverages`: An empty array `[]`.
*   **Expectations:**
    *   `feeCalculation` is generated based on `billingPeriodItems` only.
    *   `totalDueAmount` reflects only the costs from `billingPeriodItems`.
    *   `createAndFinalizeSubscriptionFeeCalculation` is called with `usageOverages: []`.

### Scenario 2.2: With usage overages increasing total due amount
*   **Setup:**
    *   Standard setup as above.
    *   `usageOverages`: Contains one or more entries with positive balances.
*   **Expectations:**
    *   `createAndFinalizeSubscriptionFeeCalculation` is called with the provided `usageOverages`.
    *   `feeCalculation` reflects the inclusion of these overages.
    *   `totalDueAmount` is higher compared to Scenario 2.1, incorporating costs derived from `usageOverages`. (The exact calculation depends on the internal logic of `createAndFinalizeSubscriptionFeeCalculation` which is out of scope for this specific function's unit test, but we should verify it's called correctly).

### Scenario 2.3: With usage overages that are zero
*   **Setup:**
    *   Standard setup as above.
    *   `usageOverages`: Contains one or more entries with `balance: 0`.
*   **Expectations:**
    *   `createAndFinalizeSubscriptionFeeCalculation` is called with the provided `usageOverages`.
    *   `totalDueAmount` is not affected by these zero-balance overages (i.e., same as Scenario 2.1).

## 3. `executeBillingRunCalculationAndBookkeepingSteps`

This function orchestrates several steps, including fetching `usageOverages` via `tabulateOutstandingUsageCosts`.

### Scenario 3.1: Billing run with usage overages leading to increased total due
*   **Setup:**
    *   `BillingRun`, `BillingPeriod`, `BillingPeriodItems` (e.g., a base subscription fee).
    *   Mock `tabulateOutstandingUsageCosts` to return `usageOverages` with positive balances.
*   **Expectations:**
    *   `calculateFeeAndTotalAmountDueForBillingPeriod` is called with the `usageOverages` from `tabulateOutstandingUsageCosts`.
    *   `billingPeriodItemsToInvoiceLineItemInserts` is called with these `usageOverages`.
    *   The resulting `Invoice` contains line items for both base fees and usage (derived from overages).
    *   `totalDueAmount` is correctly calculated, including overage costs.
    *   A `Payment.Insert` is prepared with this `totalDueAmount`.
    *   `BillingRun` status is updated to `AwaitingPaymentConfirmation`.

### Scenario 3.2: Billing run with usage overages, but total due is zero or negative
*   **Setup:**
    *   Similar to 3.1, but `billingPeriodItems` might include significant credits, or `usageOverages` are small/zero, resulting in `totalDueAmount <= 0`.
    *   Mock `tabulateOutstandingUsageCosts` accordingly.
*   **Expectations:**
    *   `totalDueAmount` is calculated to be `<= 0`.
    *   `processNoMoreDueForBillingPeriod` is called.
    *   The `Invoice` status is updated to `Paid`.
    *   The `BillingRun` status is updated to `Succeeded`.
    *   No `Payment` record is created or attempted for charge.

### Scenario 3.3: Interaction with an existing invoice when usage overages are present
*   **Setup:**
    *   An existing `Invoice` (not in a terminal state) for the `billingPeriodId`.
    *   Mock `tabulateOutstandingUsageCosts` to return new/different `usageOverages`.
*   **Expectations:**
    *   Existing invoice line items for the invoice are deleted.
    *   New invoice line items are created using `billingPeriodItemsToInvoiceLineItemInserts` and the new `usageOverages`.
    *   The flow proceeds based on the recalculated `totalDueAmount` (either creating a payment or marking as paid).

### Scenario 3.4: `tabulateOutstandingUsageCosts` returns empty `usageOverages`
*   **Setup:**
    *   Mock `tabulateOutstandingUsageCosts` to return an empty array for `rawOutstandingUsageCosts`.
*   **Expectations:**
    *   `calculateFeeAndTotalAmountDueForBillingPeriod` is called with `usageOverages: []`.
    *   `billingPeriodItemsToInvoiceLineItemInserts` is called with `usageOverages: []`.
    *   Calculations and invoice line items proceed as if there were no usage component beyond what's in `billingPeriodItems`.

## 4. `executeBillingRun`

This is the main orchestrator. Tests should cover the end-to-end impact of `usageOverages`.

### Scenario 4.1: End-to-end flow with significant usage overages
*   **Setup:**
    *   A `BillingRun` in `Scheduled` status.
    *   Relevant `Customer`, `Subscription`, `BillingPeriod`, `PaymentMethod`.
    *   `billingPeriodItems` representing a base fee.
    *   Mock `tabulateOutstandingUsageCosts` (within the `comprehensiveAdminTransaction` of `executeBillingRunCalculationAndBookkeepingSteps`) to return `usageOverages` that result in a `totalAmountToCharge > 0`.
    *   Mock `createAndConfirmPaymentIntentForBillingRun` to simulate successful payment intent creation.
    *   Mock `generateInvoicePdfTask.trigger`.
*   **Expectations:**
    *   `executeBillingRunCalculationAndBookkeepingSteps` processes the overages correctly.
    *   `calculateTotalAmountToCharge` yields a positive amount.
    *   `createAndConfirmPaymentIntentForBillingRun` is called with the correct amount (including overages) and other details.
    *   `Payment`, `Invoice`, and `BillingRun` records are updated with payment intent details and appropriate statuses (e.g., `AwaitingPaymentConfirmation`).
    *   The ledger command in the `comprehensiveAdminTransaction` includes the `payment` record which reflects the `totalDueAmount` with overages.

### Scenario 4.2: End-to-end flow where usage overages result in no charge needed
*   **Setup:**
    *   Similar to 4.1, but `tabulateOutstandingUsageCosts` and/or `billingPeriodItems` result in `totalAmountToCharge <= 0`.
*   **Expectations:**
    *   `executeBillingRunCalculationAndBookkeepingSteps` determines `totalDueAmount <= 0`.
    *   `calculateTotalAmountToCharge` results in `<=0`.
    *   `createAndConfirmPaymentIntentForBillingRun` is *not* called.
    *   Invoice status is updated to `Paid` (if applicable from `processNoMoreDueForBillingPeriod` or if `totalAmountToCharge <= 0` after calculations).
    *   BillingRun status is updated to `Succeeded` (if `totalDueAmount <= 0`).

## Notes for Implementation:
*   When mocking `tabulateOutstandingUsageCosts`, ensure the returned structure for `usageOverages` matches its definition: `Array<{ usageMeterId: string; balance: number; }>` as used by `calculateFeeAndTotalAmountDueForBillingPeriod` and `billingPeriodItemsToInvoiceLineItemInserts`.
*   For tests involving `createAndFinalizeSubscriptionFeeCalculation`, the primary goal for these unit tests is to ensure it's *called* with the correct `usageOverages`. The detailed internal logic of fee calculation with overages would be tested in `createAndFinalizeSubscriptionFeeCalculation`'s own unit tests.
*   Remember to set up necessary related data like `UsageMeter` records if `billingPeriodItems` of type `Usage` are used, or if `usageOverages` refer to specific `usageMeterId`s.

# Test Case Plan for `processPaymentIntentEventForBillingRun` and Ledger Commands

This plan outlines test cases for `processPaymentIntentEventForBillingRun`, with a focus on when the `SettleInvoiceUsageCostsLedgerCommand` should be issued.

## 1. Mapping Payment Status to Ledger Command Issuance

The core logic dictates that a ledger command is issued only when an invoice is moved to a `Paid` status, which should happen upon a successful payment.

### Scenario 1.1: `PaymentIntentSucceededEvent` (Happy Path)
*   **Setup:** A standard billing run with an `Invoice` containing both usage-based and static line items. The associated `Payment` is in a `Processing` state.
*   **Trigger:** A `Stripe.PaymentIntentSucceededEvent`.
*   **Expectations:**
    *   The `BillingRun` status becomes `Succeeded`.
    *   The `Invoice` status becomes `Paid`.
    *   A `SettleInvoiceUsageCostsLedgerCommand` is returned in the function's output.
    *   The command's payload correctly references the paid `invoice` and its `invoiceLineItems`.

### Scenario 1.2: `PaymentIntentSucceededEvent` with no usage costs
*   **Setup:** An invoice that only contains static, non-usage-based line items.
*   **Trigger:** A `Stripe.PaymentIntentSucceededEvent`.
*   **Expectations:**
    *   The `BillingRun` and `Invoice` are marked as `Succeeded` and `Paid`, respectively.
    *   A `SettleInvoiceUsageCostsLedgerCommand` is **still returned**. The command itself is responsible for gracefully handling the absence of usage items, so the producer (`processPaymentIntentEventForBillingRun`) should issue it regardless.

### Scenario 1.3: Non-Succeeded PaymentIntents (`PaymentFailed`, `Canceled`, `Processing`, `RequiresAction`)
*   **Setup:** A standard billing run.
*   **Trigger:** Process each of the following events in separate tests:
    *   `Stripe.PaymentIntentPaymentFailedEvent`
    *   `Stripe.PaymentIntentCanceledEvent`
    *   `Stripe.PaymentIntentProcessingEvent`
    *   `Stripe.PaymentIntentRequiresActionEvent`
*   **Expectations:**
    *   The `BillingRun` and `Invoice` are updated to their corresponding non-paid statuses (`Failed`, `Aborted`, `AwaitingPaymentConfirmation`, etc.).
    *   Crucially, the `ledgerCommand` property in the returned result must be `undefined` for all these cases.

## 2. Idempotency

Idempotency is critical. While the `settleInvoiceUsageCostsLedgerCommand` should be idempotent, the event processor should also avoid issuing duplicate commands.

### Scenario 2.1: Processing the same `PaymentIntentSucceededEvent` twice
*   **Setup:** A standard billing run setup.
*   **Trigger:**
    1.  Process a `PaymentIntentSucceededEvent`.
    2.  Process the *exact same event* a second time.
*   **Expectations:**
    *   The first call processes the event, updates the database state, and returns a `SettleInvoiceUsageCostsLedgerCommand`.
    *   The `lastPaymentIntentEventTimestamp` on the `BillingRun` record is updated.
    *   The second call, seeing an event timestamp that is not newer than the one recorded, should be a no-op in terms of state changes.
    *   The second call must return a result where the `ledgerCommand` is `undefined`.

### Scenario 2.2: Processing an older, out-of-order event
*   **Setup:** Manually set the `lastPaymentIntentEventTimestamp` on a `BillingRun` to a known future time.
*   **Trigger:** Process a `PaymentIntentSucceededEvent` with a `created` timestamp *before* the `lastPaymentIntentEventTimestamp`.
*   **Expectations:**
    *   The function should immediately exit without processing.
    *   No database state should change.
    *   The function must return a result where the `ledgerCommand` is `undefined`. (This confirms existing tests in the context of the new functionality).


# Test Case Plan for `processSetupIntent.ts`

This document outlines additional test cases for `processSetupIntent.ts`.

## 1. `processAddPaymentMethodSetupIntentSucceeded`

This function handles the bookkeeping for a successful `setupIntent` when the checkout session is for adding a new payment method.

### Scenario: Automatically updating subscriptions
*   **Setup:**
    *   A `customer` with multiple `subscriptions`, each with an existing `paymentMethod`.
    *   A `checkoutSession` of type `AddPaymentMethod` with `automaticallyUpdateSubscriptions: true`.
    *   A successful `setupIntent` for this checkout session, containing a new Stripe payment method ID.
*   **Expectations:**
    *   `safelyUpdateSubscriptionsForCustomerToNewPaymentMethod` is called.
    *   All of the customer's subscriptions are updated to use the new payment method created from the `setupIntent`.
    *   The old payment method is no longer the default for any of the updated subscriptions.

### Scenario: NOT automatically updating subscriptions
*   **Setup:**
    *   A `customer` with multiple `subscriptions`, each with an existing `paymentMethod`.
    *   A `checkoutSession` of type `AddPaymentMethod` with `automaticallyUpdateSubscriptions: false` (or undefined).
    *   A successful `setupIntent` for this checkout session.
*   **Expectations:**
    *   `safelyUpdateSubscriptionsForCustomerToNewPaymentMethod` is **not** called.
    *   The customer's subscriptions retain their original payment methods.

# Test Case Plan for `createSubscription.ts`

This document outlines the test cases for functions within `createSubscription.ts`, primarily focusing on `insertSubscriptionAndItems` and its direct helper functions.

## 1. `insertSubscriptionAndItems`

This function is the main entry point for creating a subscription record and its associated items. It acts as a router to different creation functions based on the price configuration.

### Scenario 1.1: Price is not a valid subscription type
*   **Setup:**
    *   Provide `params` with a `price` object where `price.type` is an invalid type (i.e., one for which `isPriceTypeSubscription` returns `false`).
*   **Expectations:**
    *   The function should throw an `Error` with the message "Price is not a subscription".

### Scenario 1.2: Price starts with a credit trial
*   **Setup:**
    *   Provide `params` where `price.startsWithCreditTrial` is `true`.
    *   The `price.type` must be `Usage` to be valid for a credit trial.
*   **Expectations:**
    *   The function should call `createCreditTrialSubscriptionAndItems` with the provided `params`.
    *   The function should **not** call `createStandardSubscriptionAndItems`.
    *   The return value should be the result from `createCreditTrialSubscriptionAndItems`.

### Scenario 1.3: Price is for a standard subscription (no trial)
*   **Setup:**
    *   Provide `params` where `price.startsWithCreditTrial` is `false` or not defined.
    *   The `price.type` is `Subscription`.
    *   No `trialEnd` date is provided.
*   **Expectations:**
    *   `generateNextBillingPeriod` is called to determine the billing cycle.
    *   The function should call `createStandardSubscriptionAndItems` with the provided `params` and the calculated `currentBillingPeriod`.
    *   The function should **not** call `createCreditTrialSubscriptionAndItems`.
    *   The return value should be the result from `createStandardSubscriptionAndItems`.

### Scenario 1.4: Price is for a standard subscription with a trial period
*   **Setup:**
    *   Provide `params` where `price.startsWithCreditTrial` is `false`.
    *   The `price.type` is `Subscription`.
    *   A future date is provided for `trialEnd`.
*   **Expectations:**
    *   `generateNextBillingPeriod` is called with the `trialEnd` date, which will affect the resulting billing period dates.
    *   The function should call `createStandardSubscriptionAndItems` with the provided `params` and the calculated `currentBillingPeriod`.
    *   The subscription created should have a `status` of `trialing`.

## 2. `createStandardSubscriptionAndItems`

This function handles the creation of regular subscriptions (which can be active, trialing, or incomplete).

### Scenario 2.1: Creates an `active` subscription
*   **Setup:**
    *   `params` contains `autoStart: true` and a valid `defaultPaymentMethod`.
    *   `params` does not contain a `trialEnd` date.
    *   `price.type` is `Subscription`.
*   **Expectations:**
    *   `deriveSubscriptionStatus` is called and returns `SubscriptionStatus.Active`.
    *   An `insertSubscription` call is made with `status: 'active'`, `runBillingAtPeriodStart: true`, and the `defaultPaymentMethodId`.
    *   An `bulkInsertSubscriptionItems` call is made with a `SubscriptionItem` of `type: 'static'`.

### Scenario 2.2: Creates a `trialing` subscription
*   **Setup:**
    *   `params` contains a `trialEnd` date in the future.
*   **Expectations:**
    *   `deriveSubscriptionStatus` is called and returns `SubscriptionStatus.Trialing`.
    *   An `insertSubscription` call is made with `status: 'trialing'` and the `trialEnd` date set.

### Scenario 2.3: Creates an `incomplete` subscription
*   **Setup:**
    *   `params` has `autoStart: false` (or undefined).
    *   `params` has no `defaultPaymentMethod`.
    *   `params` has no `trialEnd` date.
*   **Expectations:**
    *   `deriveSubscriptionStatus` is called and returns `SubscriptionStatus.Incomplete`.
    *   An `insertSubscription` call is made with `status: 'incomplete'` and `defaultPaymentMethodId: null`.

### Scenario 2.4: Subscription with a usage-based price
*   **Setup:**
    *   `params` for a standard subscription.
    *   `price.type` is `Usage`.
*   **Expectations:**
    *   An `insertSubscription` call is made with `runBillingAtPeriodStart: false`.
    *   An `bulkInsertSubscriptionItems` call is made with a `SubscriptionItem` that has `type: 'static'`, `usageMeterId: null`, and `usageEventsPerUnit: null`, confirming the current implementation.

### Scenario 2.5: Uses a provided name for the subscription
*   **Setup:**
    *   `params` includes a `name` string.
*   **Expectations:**
    *   An `insertSubscription` call is made with the `name` from `params`.

### Scenario 2.6: Constructs a default name for the subscription
*   **Setup:**
    *   `params` does not include a `name`.
    *   `product.name` and `price.name` are provided.
*   **Expectations:**
    *   An `insertSubscription` call is made with a constructed name (e.g., `PRODUCT_NAME - PRICE_NAME`).

## 3. `createCreditTrialSubscriptionAndItems`

This function handles the specific case of creating a subscription that starts with a credit trial.

### Scenario 3.1: Happy path credit trial creation
*   **Setup:**
    *   `params` where `price.type` is `Usage` and `price.usageMeterId` is not null.
*   **Expectations:**
    *   The function completes successfully.
    *   An `insertSubscription` call is made with `status: 'credit_trial'`, `runBillingAtPeriodStart: false`, and `null` for billing period dates.
    *   An `bulkInsertSubscriptionItems` call is made with a `SubscriptionItem` of `type: 'usage'` and the correct `usageMeterId` from the price.
    *   The function returns the newly created subscription and subscription item records.

### Scenario 3.2: Price is not a usage price
*   **Setup:**
    *   `params` where `price.type` is `Subscription` or another non-`Usage` type.
*   **Expectations:**
    *   The function throws an `Error` with the message "Price ... is not a usage price. Credit trial subscriptions must have a usage price...".

